import { and, desc, eq, exists, like, or } from 'drizzle-orm';
import { database } from '../database/database.js';
import { chat } from '../database/tables/chat.js';
import { message } from '../database/tables/message.js';
import { AuthHandler } from '../helpers/auth-handler.js';
import { Logger } from '../helpers/custom-logger.js';
import { event, service, streamHandler } from '../helpers/decorators.js';
import { StreamContext } from '../helpers/stream-manager.js';

@service
class ChatService {

  @streamHandler('chat.stream')
  async handleChatStream(data: ChatStreamData, stream: StreamContext) {
    try {
      // if there is a pending assistant message for this chat, update it to error and continue
      await database()
        .update(message)
        .set({
          status: 'error',
        })
        .where(and(
          eq(message.chat_id, data.chatId),
          eq(message.type, 'assistant'),
          eq(message.status, 'pending')
        ));


      // create a new user message
      const userMessage = await database()
        .insert(message)
        .values({
          chat_id: data.chatId,
          type: 'user',
          content: data.message,
          status: 'success',
          metadata: null
        })
        .returning();

      // update the chat's updated_at timestamp
      await database()
        .update(chat)
        .set({
          updated_at: new Date().toISOString(),
        })
        .where(eq(chat.id, data.chatId));


      // create an empty assistant message
      const assistantMessage = await database()
        .insert(message)
        .values({
          chat_id: data.chatId,
          type: 'assistant',
          content: '',
          status: 'pending',
          metadata: null
        })
        .returning();

      // send message start notification
      stream.write({
        type: 'message_start',
        data: {
          chatId: data.chatId,
          agentMessageId: assistantMessage[0].id,
          userMessageId: userMessage[0].id,
          userMessage: {
            content: data.message,
          }
        }
      } as ChatResponseChunk);


      // stream response chunks (simulating AI response)
      const responseText = `This is a simulated response to the message: "${data.message}". It will be streamed in chunks as if it were generated by an AI model.`;
      let accumulatedText = '';
      for (const chunk of responseText.split(' ')) {
        await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));
        accumulatedText += (accumulatedText ? ' ' : '') + chunk;
        if (stream.isStreamEnded()) break;
        stream.write({
          type: 'content_chunk',
          data: {
            chunk: chunk,
            fullContent: accumulatedText,
            agentMessageId: assistantMessage[0].id,
            userMessageId: userMessage[0].id,
          },
        } as ChatResponseChunk);
      }


      // update message status to success
      await database()
        .update(message)
        .set({
          status: 'success',
          content: accumulatedText,
        })
        .where(eq(message.id, assistantMessage[0].id));

      // complete the stream
      stream.end({
        type: 'content_complete',
        data: {
          agentMessageId: assistantMessage[0].id,
          userMessageId: userMessage[0].id,
        }
      } as ChatResponseChunk);

    } catch (error) {
      // update last message status to error
      await database()
        .update(message)
        .set({
          status: 'error',
        })
        .where(and(
          eq(message.chat_id, data.chatId),
          eq(message.type, 'assistant'),
          eq(message.status, 'pending')
        ));

      Logger.error("Error in chat stream handler:", error);
      stream.error(error instanceof Error ? error.message : 'Unknown error occurred')
    }
  }

  @event('chat.getAll', 'handle')
  public async getChats(options: {
    limit?: number;
    offset?: number;
    search?: string;
  } = {}) {
    try {
      const whereConditions = [eq(chat.user_id, AuthHandler.profile!.sub)];

      if (options.search) {
        // Search in both chat title and message content
        const searchConditions = or(
          like(chat.title, `%${options.search}%`),
          // Check if any message in this chat contains the search term
          exists(
            database()
              .select()
              .from(message)
              .where(
                and(
                  eq(message.chat_id, chat.id),
                  like(message.content, `%${options.search}%`)
                )
              )
          )
        )!;
        whereConditions.push(searchConditions);
      }

      const rows = await database()
        .select()
        .from(chat)
        .where(and(...whereConditions))
        .limit(options.limit || 50)
        .offset(options.offset || 0)
        .orderBy(desc(chat.updated_at));

      return rows;
    } catch (error) {
      Logger.error("Error fetching chats:", error);
      return []
    }
  }

  @event('chat.getById', 'handle')
  public async getChatById(chatId: number) {
    try {
      const [data] = await database()
        .select()
        .from(chat)
        .where(and(
          eq(chat.id, chatId),
          eq(chat.user_id, AuthHandler.profile!.sub)
        ))
      return data;
    } catch (error) {
      Logger.error("Error fetching chat by ID:", error);
      return null;
    }
  }

  @event('chat.create', 'handle')
  public async createChat(data: {
    title?: string;
    metadata?: any;
  }) {
    try {
      const [newChat] = await database()
        .insert(chat)
        .values({
          title: data.title || `New Chat ${Date.now()}`,
          user_id: AuthHandler.profile!.sub,
        })
        .returning()
      return newChat;
    } catch (error) {
      Logger.error("Error creating chat:", error);
      return null;
    }
  }

  @event('chat.update', 'handle')
  public async updateChat(chatId: number, updates: typeof chat.$inferInsert) {
    try {
      const rows = await database()
        .update(chat)
        .set({
          ...updates,
          id: chatId,
          user_id: AuthHandler.profile!.sub,
        })
        .where(and(
          eq(chat.id, chatId),
          eq(chat.user_id, AuthHandler.profile!.sub)
        ))

      return rows.changes > 0;
    } catch (error) {
      Logger.error("Error updating chat:", error);
      return false;
    }
  }

  @event('chat.delete', 'handle')
  public async deleteChat(chatId: number) {
    try {
      const deletedRows = await database()
        .delete(chat)
        .where(and(
          eq(chat.id, chatId),
          eq(chat.user_id, AuthHandler.profile!.sub)
        ));

      return deletedRows.changes > 0;
    } catch (error) {
      Logger.error("Error deleting chat:", error);
      return false;
    }
  }
}

const instance = new ChatService();
export { instance as ChatService };


interface ChatStreamData {
  chatId: number;
  message: string;
}

interface ChatResponseChunk_MessageStart {
  type: 'message_start';
  data: {
    chatId: number;
    agentMessageId: number;
    userMessageId: number;
    userMessage: {
      content: string;
    }
  }
}

interface ChatResponseChunk_ContentChunk {
  type: 'content_chunk';
  data: {
    chunk: string;
    fullContent: string;
    agentMessageId: number;
    userMessageId: number;
  };
}

interface ChatResponseChunk_ContentComplete {
  type: 'content_complete';
  data: {
    agentMessageId: number;
    userMessageId: number;
  }
}

interface ChatResponseChunk_Error {
  type: 'error';
  data: {
    error: string;
    chatId?: number;
    userMessageId: number;
    agentMessageId: number;
  };
}

type ChatResponseChunk = ChatResponseChunk_MessageStart | ChatResponseChunk_ContentChunk | ChatResponseChunk_ContentComplete | ChatResponseChunk_Error;
